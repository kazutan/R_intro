---
title: データの整形・加工
---

ここでは、読み込んだデータを整形したり加工したりするのによく使う関数を紹介します。なお、ここではデータフレームを念頭においています。

## 使用するデータ

説明で使用するデータフレームとして、Rにもともと組み込まれている`iris`データを使用します。

```{r}
names(iris)
str(iris)
head(iris)
```

## データフレームの要素へのアクセス

データフレーム内の要素へアクセス(選択・指定)する方法を紹介します。**これが基本かつ最重要**です。

データハンドリングは「操作したいターゲットを指定」することが第一歩となります。操作したいターゲットを指定できるのであれば、あとはそれを処理してしまえばいいのです。逆に**これができないと何もできない**こととなります。Excelなどと違い、Rは関数で指定していくため、最初に躓くポイントです。

### 行番号・列番号を使ったアクセス

行番号を指定してアクセスするには、以下のようにやります:

```{r}
iris[3,]  # 3行目(全部)にアクセス
```

データフレーム名のすぐ後に角括弧`[,]`をつけ、その中で数値を指定するとその要素へアクセスできます。`[行,列]`とイメージしてください。

列番号を指定してアクセスするには、以下のような感じになります:

```{r}
x <- iris[, 2] # irisの2列目にアクセス
head(x, 5)  # 長いので上から5つ分取り出す
```

考え方は行番号で説明したのと同様です。もちろん両方同時に指定してアクセスもできます:

```{r}
iris[3, 2] # 20行目の2列目にアクセス
```

まずは行と列になれましょう。

### 複数の行番号(や列番号)をまとめてアクセス

```{r}
iris[21:24,]  # 21行目から24行目へアクセス
```

行番号を`:`でつなぐと連番を持ってきます。なお、この`:`は数値の連番が入ったベクトルを返す演算子です:

```{r}
3:8
```

つまり、`[ , ]`では**数値ベクトルを与えればその数値にアクセスしてくれる**のです:

```{r}
x <- iris[, c(2,5)] # 2列目と5列目へアクセス 
head(x, 5) # 長いので5行分
```

`c(2,5)`は`2`と`5`がはいった数値ベクトルなので、2列目と5列目にアクセスするようになります。

もちろん、両方を同時に指定できます:

```{r}
iris[21:24, c(2, 5)]
```

### ある列(行)番号を除外してアクセス

「ある要素を除外する」という場合には、`-`を活用します:

```{r}
iris[21:24,-5]  # 21-24行目から、5列目を除外
```

行番号や列番号は正の整数しか存在しないため、`-`を負の値とはみなさす、このように処理してくれるんだと思います。`:`を使った連番では以下のようになります:

```{r}
iris[21:24,-4:-5]  # 21-24行目から4,5列目を除外
```

`-4:-5`は`-4と`-5`が入った数値ベクトルを返してくるため、その2つが効果を発揮します。なお、数値ベクトルを準備してそれを除外することもできます:

```{r}
iris[21:24, -c(2, 5)] #21-24行目から2列目と5列目を除外
```

おそらくは最後の例を基本に考えていたほうがいいでしょう。

### 変数名(列名)を使ってアクセス

通常、列番号ではなく変数名(列名)を使うことが多いかと思います。この場合、以下のように指定します:

```{r}
x <- iris$Sepal.Width # irisのSepal.Widthにアクセス
head(x, 3) # 上から3行分
```

`データフレーム名$変数名`で指定可能です。なおRStudioなら、この`$`を入力したら候補が出てきますので、選択が楽になるはずです。もしデータフレーム内の変数リストがほしい時は`ls()`関数が便利です:

```{r}
ls(iris)  #iris内の変数(オブジェクト)リストを出力
```

## `subset()`関数を使ってアクセス

`subset()`はデータフレームから切り出してサブデータセットを作るイメージです。`[ , ]`で説明したような内容をスムーズに行なえます。

### selectオプションで列番号指定

```{r}
x <- subset(iris, select = 2:3) # irisから2:3列目を選択
head(x, 3) # xの3行分
```

`subset()`関数の第一引数にデータフレームを指定し、`select=`引数で列を指定します。考え方は上述の`[,]`と同様です。

### 変数名(列名)を使ってアクセス

```{r}
x <- subset(iris, select = Sepal.Width) #irisからSepal.Widthを選択
head(x, 3)
```

selectに変数名を直接指定することも可能です。文字列(`"Sepal.Width"`のようなもの)でもOKです。複数の列名を指定してアクセスも可能です:

```{r}
x <- subset(iris, select = c(Sepal.Length,Sepal.Width))
head(x, 3)
```

このように、`select=`にベクトルでもOKとなります。また、変数が並んでいるときなどは、以下のように`:`を使うこともできます:

```{r}
x <- subset(iris, select = Sepal.Length:Petal.Length)
head(x, 3)
```

irisデータはSepal.Lengthが1列目、Petal.Lengthは3行目にあるので、1列目から3列目まで持ってくるようになります。使いドコロとしては、心理尺度などで`s101`から`s110`までの変数が並んでいる場合、以下のようにアクセスすることが可能となります:

```{r, eval=FALSE}
# hogeというデータフレームにs101からs110まで並んで入っているとします
subset(hoge, select = s101:s110)
```

また、除外する変数を変数名で指定することも可能です。考え方は`[,]`と同様で`-`を利用します:

```{r}
x <- subset(iris, select = -c(Sepal.Length,Species))
head(x, 2)
```

これで除外できます。なお、指定する変数名は文字列ベクトルで与えることができるので、こんな感じで準備することもできます:

```{r}
select_list1 <- paste("se", c(1, 3, 5, 8, 10), sep = "")
select_list1
```

あるいは正規表現を使って、以下のように指定することもできたりします:

```{r}
# ls(iris)でiris内の変数名を取得し、その中から「冒頭に"S"がある」ものを持ってくる
x <- subset(iris, select = grep("^S", ls(iris)))
head(x, 3)
```

このあたりは結構応用的で難しく感じるかもしれません。そのうちでいいと思います。

### レコード(行)に条件を指定してアクセス

条件を指定して、レコードを抽出することができます:

```{r}
subset(iris, subset = Sepal.Width>4.0)
```

`subset = (条件式)`で、その条件にマッチするレコード(行)にアクセスします。この場合、「Sepal.Widthが4より大きい行」を抽出してきます。もちろん上述の列を指定する`select=`と同時に使えます:

```{r}
subset(iris, select = 2:3, subset = Sepal.Width>4.0)
```

以上は`>=`で、以下は`<=`が演算子となります:

```{r}
subset(iris, subset = Sepal.Width>=4.0)
```

「~と等しい」という場合には`==`が演算子となります:

```{r}
x <- subset(iris, subset = Species=="setosa")
head(x)
```

「~と等しくない(~ではない)」という場合は、`!=`が演算子となります:

```{r}
x <- subset(iris, subset = Species!="setosa")
x[sample(nrow(x), size = 10),] #ランダムに10行持ってくる
```

もし、「AまたはBのどちらかとマッチするもの」を取り出したい場合、`%in%`演算子を使います:

```{r}
x <- subset(iris, subset = Species %in% c("setosa", "versicolor"))
x[sample(nrow(x), size = 10),] #ランダムに10行持ってくる
```

条件が複数ある場合、ANDなら&でつなぎ、ORなら|でつなぎます:

```{r}
subset(iris, subset = Sepal.Width>3.5 & Petal.Width>1.0)
subset(iris, subset = Sepal.Width>4.0 | Petal.Width>2.0)
```

文字列の部分一致も以下のように実行すればできます:

```{r}
x <- subset(iris, subset = grepl("sa", iris$Species))
x[sample(nrow(x), 10),]
```

詳細は省略します。。

## データの操作

### 変数の変換(他の変数へ)

既存の変数に処理をして、他の変数へ出す場合は、`transform()`関数を使用します:

```{r}
x <- transform(iris, kazu=Sepal.Width+5)
head(x,3)
```

第一引数に元となるデータフレーム、以降に新しい変換した変数を定義します。

### 変数の変換(更新)

先の新しい変数名を、既存の変数名にすると、その変数が上書きされて更新されます:

```{r}
x <- transform(x, kazu=Sepal.Width+5)
```

基本、「元に戻す」という機能はないので、こういうデータハンドリングはコードをスクリプトに残すようにして履歴をたどれるようにしておいてください。

### 欠損値がある行の除去

サンプルとして、以下のデータフレームを準備します:

```{r echo=FALSE}
x <- data.frame(x1=c(1:3,NA,5),y1=c(11:12,NA,14:15))
x
```

このデータフレームからNAを含む行を削除するには、以下のようにします:

```{r}
x[complete.cases(x),]
```

分析に使う関数によっては、`na.rm=`という引数が使えることもあるので、各関数のヘルプを確認してください。

### 行和の算出

行和(横方向へ足し算)するときは、`rowSums()`関数を使用します:

```{r}
x <- subset(iris, select = -Species)
head(x)
head(rowSums(x))
```

多くの場合、そのデータフレームに新たな列として追加したいでしょうから、以下のような感じになります:

```{r}
x$rsum <- rowSums(x)
head(x)
```

上の`x$rsum`のように、存在しない変数に対してベクトルを放り込むと、新しくその変数(列)が作られます。

### 行平均の算出

行平均を算出するときは、`rowMeans()`関数を利用します。使い方は`rowSums()`と同様です:

```{r}
x <- subset(iris, select = -Species)
head(x)
head(rowMeans(x))
```

実際の場合では、このような使い方になるかと:

```{r}
x$rmean <- rowMeans(x)
head(x)
```

なお、`rowSums()`も`rowMeans()`も文字列など計算できない変数が含まれているとエラーを出しますので注意してください。また、`na.rm=`オプションが使えますので、必要に応じて使ってください。


## データフレームの結合

2つのデータフレームを準備します:

```{r}
x <- data.frame(a=1:3,b=c("A","B","C"),c=11:13)
x
y <- data.frame(a=2:4,b=c("B","C","D"),d=12:14)
y
```

以降、これを使って説明します。

### 両方に含まれる列をキーとして結合

データフレームを結合するには、`merge()`関数を使用します:

```{r}
merge(x,y)
```

この場合、`x`と`y`で共通する変数(この場合`a`と`b`)をキー変数として、**その2つが一致する行のみ取り出して結合**させます。片方しかない列は、それぞれ残ることとなります。

### 両方を網羅して結合

データを落とすことなく結合させるには、`all=TRUE`という引数を与えます:

```{r}
merge(x,y,all=TRUE)
```

この場合、2つのデータフレームで共通する列をキー変数として結合し、キー変数が一致しないレコード(行)は追加されます。なお値がない部分については`NA`が入ります。

### データフレームに行を追加

データフレームに行を追加する場合、`rbind()`関数を使用します:

### データフレームに列を追加

データフレームに列を追加する場合、`cbind()`関数を使用します:

## パッケージを利用したデータハンドリング

最近では、このようなデータハンドリングは専用のパッケージを利用することが多くなっています。この方が効率的に処理でき、また処理が高速な場合が多いためです。

代表的なパッケージとして、dplyrパッケージがあります。またデータの縦・横変換などに効果を発揮するtidyrパッケージも有用です。この2つの関数の基本的な使い方については、以下のドキュメントを参照してください:

[データハンドリング](http://kazutan.github.io/HijiyamaR4/data_handling_d.html)

[ページのトップへ](#)